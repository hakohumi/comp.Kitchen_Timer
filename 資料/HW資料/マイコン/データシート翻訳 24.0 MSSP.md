# 24.0マスター同期

シリアルポート（MSSP1およびMSSP2）モジュール

## 24.1マスターSSPx（MSSPx）モジュールの概要

マスター同期シリアルポート（MSSPx）モジュールは、他の周辺機器またはマイクロコントローラーデバイスとの通信に役立つシリアルインターフェイスです。これらの周辺デバイスには、シリアルEEPROM、シフトレジスタ、ディスプレイドライバ、A / Dコンバータなどがあります。MSSPxモジュールは、次の2つのモードのいずれかで動作できます。
•シリアルペリフェラルインターフェイス（SPI）
•相互統合回路（I2C™）
SPIインターフェイスは、次のモードと機能をサポートしています。
•マスターモード
•スレーブモード
•クロックパリティ
•スレーブ選択同期（スレーブモードのみ）
•スレーブデバイスのデイジーチェーン接続
図24-1は、SPIインターフェイスモジュールのブロック図です。

I2Cインターフェイスは次のモードをサポートし、
特徴：
•マスターモード
•スレーブモード
•バイトNACKing（スレーブモード）
•限定的なマルチマスターサポート
•7ビットおよび10ビットのアドレス指定
•割り込みの開始と停止
•割り込みマスキング
•クロックストレッチ
•バス衝突検出
•一般的なコールアドレスマッチング
•アドレスマスキング
•アドレス保持モードとデータ保持モード
•選択可能なSDAxホールドタイム
図24-2は、マスターモードのI2Cインターフェイスモジュールのブロック図です。図24-3は、スレーブモードのI2Cインターフェイスモジュールの図です。

PIC16F1827には2つのMSSPモジュール、MSSP1とMSSP2があり、各モジュールは互いに独立して動作します。

注1：複数のMSSPモジュールを備えたデバイスでは、SSPxCONxレジスタ名に細心の注意を払うことが非常に重要です。
SSP1CON1およびSSP1CON2レジスタは、同じモジュールのさまざまな動作を制御し、SSP1CON1およびSSP2CON1は、2つの異なるモジュールの同じ機能を制御します。
2：このセクション全体で、その動作モードのいずれかにおけるMSSPモジュールへの一般的な参照は、MSSP1またはMSSP2にも同様に適用可能であると解釈される場合があります。レジスタ名、モジュールI / O信号、およびビット名は、必要に応じて特定のモジュールを区別するための数字の使用を示すために、総称指定子「x」を使用できます。




## 24.2 SPI Mode Overview

シリアルペリフェラルインターフェイス（SPI）バスは、全二重モードで動作する同期シリアルデータ通信バスです。
 デバイスは、マスターデバイスが通信を開始するマスター/スレーブ環境で通信します。
 スレーブデバイスは、スレーブセレクトと呼ばれるチップセレクトを介して制御されます。
 SPIバスは4つの信号接続を指定します。
•シリアルクロック（SCKx）
•シリアルデータ出力（SDOx）
•シリアルデータ入力（SDIx）
•スレーブ選択（SSx）
図24-1に、SPIモードで動作しているときのMSSPxモジュールのブロック図を示します。
 SPIバスは、単一のマスターデバイスと1つ以上のスレーブデバイスで動作します。
 複数のスレーブデバイスを使用する場合、マスターデバイスから各スレーブデバイスへの独立したスレーブ選択接続が必要です。
 図24-4は、マスターデバイスと複数のスレーブデバイス間の一般的な接続を示しています。
 マスターは一度に1つのスレーブのみを選択します。
 ほとんどのスレーブデバイスはトライステート出力を備えているため、選択されていない場合、出力信号はバスから切断されているように見えます。
 送信には、サイズが8ビットの2つのシフトレジスタが含まれ、1つはマスターに、もう1つはスレーブにあります。
 マスターまたはスレーブデバイスのいずれかを使用すると、データは常に一度に1ビットずつシフトアウトされ、最上位ビット（MSb）が最初にシフトアウトされます。
 同時に、新しい最下位ビット（LSb）が同じレジスタにシフトされます。
 図24-5は、マスターデバイスとスレーブデバイスとして構成された2つのプロセッサ間の一般的な接続を示しています。
 データは、プログラムされたクロックエッジで両方のシフトレジスタからシフトアウトされ、クロックの反対側のエッジでラッチされます。
 マスターデバイスは、スレーブのSDIx入力ピンに接続されて受信されるSDOx出力ピンで情報を送信します。
 スレーブデバイスは、マスターのSDIx入力ピンに接続されて受信されるSDOx出力ピンで情報を送信します。
 通信を開始するには、マスターデバイスは最初にクロック信号を送信します。
 マスターデバイスとスレーブデバイスの両方を同じクロック極性に設定する必要があります。
 マスターデバイスは、シフトレジスタからMSbを送信することで送信を開始します。
 スレーブデバイスは、同じビットからこのビットを読み取り、シフトレジスタのLSb位置に保存します。
 各SPIクロックサイクル中に、全二重データ送信が発生します。
 これは、マスターデバイスがシフトレジスタ（SDOxピン上）からMSbを送信していて、スレーブデバイスがこのビットを読み取ってシフトレジスタのLSbとして保存している間、スレーブデバイスがシフトレジスタからのMSb（SDOxピン上）およびマスターデバイスがこのビットを読み取り、シフトレジスタのLSbとして保存します。
 8ビットがシフトアウトされた後、マスターとスレーブはレジスタ値を交換しました。
 交換するデータがまだある場合は、シフトレジスタに新しいデータが読み込まれ、プロセスが繰り返されます。
 データが意味のあるものかどうか（ダミーデータ）は、アプリケーションソフトウェアによって異なります。
 これにより、データ転送のシナリオが3つになります。
•マスターは有用なデータを送信し、スレーブはダミーデータを送信します。
•マスターは有用なデータを送信し、スレーブは有用なデータを送信します。
•マスターはダミーデータを送信し、スレーブは有用なデータを送信します。
送信には、任意の数のクロックサイクルが含まれます。
 送信するデータがなくなると、マスターはクロック信号の送信を停止し、スレーブの選択を解除します
。スレーブ選択ラインを介して選択されていないバスに接続されているすべてのスレーブデバイスは、クロックと送信信号を無視し、独自のデータを送信してはなりません。






## 24.3 I2C MODE OVERVIEW

Inter-Integrated Circuit Bus（I²C）は、マルチマスターシリアルデータ通信バスです。
 デバイスは、マスターデバイスが通信を開始するマスター/スレーブ環境で通信します。
 スレーブデバイスは、アドレス指定によって制御されます。
 I2Cバスは2つの信号接続を指定します。
•シリアルクロック（SCLx）
•シリアルデータ（SDAx）
図24-11は、MSSPxのブロック図を示しています
I2Cモードで動作しているときのモジュール。
 SCLxとSDAxの接続はどちらも双方向のオープンドレインラインで、それぞれに電源電圧用のプルアップ抵抗が必要です。ラインを接地することは論理的なゼロと見なされ、ラインをフロートさせることは論理的な1と見なされます。
図24-11は、マスターデバイスとスレーブデバイスとして構成された2つのプロセッサ間の一般的な接続を示しています。
 I2Cバスは、1つ以上のマスターデバイスと1つ以上のスレーブデバイスで動作できます。
 特定のデバイスには、4つの潜在的な動作モードがあります。
•マスター送信モード
（マスターはスレーブにデータを送信しています）
•マスター受信モード
（マスターはスレーブからデータを受信して​​います）
•スレーブ送信モード
（スレーブはマスターにデータを送信しています）
•スレーブ受信モード
（スレーブはマスターからデータを受信して​​います）
通信を開始するには、マスターデバイスをマスター送信モードで開始します。
 マスターデバイスは、スタートビットを送信し、その後に通信するスレーブのアドレスバイトを送信します。
 この後に、1つの読み取り/書き込みビットが続きます。これは、マスターがスレーブデバイスにデータを送信するのか、スレーブデバイスからデータを受信するのかを決定します。
 要求されたスレーブがバス上に存在する場合、それは、ACKとしても知られるAcknowledgeビットで応答します。
 その後、マスターは送信モードまたは受信モードのいずれかで継続し、スレーブはそれぞれ、受信モードまたは送信モードのいずれかで補数で続行します。
 スタートビットは、SCLxラインがハイに保持されている間のSDAxラインのハイからローへの遷移によって示されます。
 アドレスバイトとデータバイトが送信され、最上位ビット（MSb）が最初に送信されます。
 読み取り/書き込みビットは、マスターがスレーブからデータを読み取ろうとするときに論理1として送信され、スレーブにデータを書き込むときに論理0として送信されます。

図24-11：I2Cマスター/スレーブ接続

肯定応答ビット（ACK）はアクティブLOW信号で、SDAxラインをローに保持して、スレーブデバイスが送信データを受信し、さらに受信する準備ができていることをトランスミッタに示します。
 SCLxラインがLowに保持されている間、データビットの遷移は常に実行されます。
 SCLxラインがHighに保持されている間に発生する遷移は、スタートビットとストップビットを示すために使用されます。
 マスターがスレーブに書き込むつもりの場合、マスターはデータのバイトを繰り返し送信し、スレーブは各バイトの後にACKビットで応答します。
 この例では、マスターデバイスはマスター送信モードにあり、スレーブはスレーブ受信モードにあります。
 マスターがスレーブから読み取るつもりの場合、マスターはスレーブから1バイトのデータを繰り返し受信し、各バイトの後にACKビットで応答します。
 この例では、マスターデバイスはマスター受信モードで、スレーブはスレーブ送信モードです。
 通信されたデータの最後のバイトで、マスターデバイスはストップビットを送信して送信を終了できます。
 マスターデバイスが受信モードの場合、最後のACKビットの代わりにストップビットを送信します。
 ストップビットは、SCLxラインがハイに保持されている間のSDAxラインのローからハイへの遷移によって示されます。場合によっては、マスターがバスの制御を維持し、別の送信を再開したいことがあります。
 その場合、マスターデバイスは、受信モードのときに、ストップビットまたは最後のACKビットの代わりに別のスタートビットを送信できます。
I2Cバスは3つのメッセージプロトコルを指定します。
•マスターがスレーブにデータを書き込む単一のメッセージ。
•マスターがスレーブからデータを読み取る単一のメッセージ。
•マスターが1つ以上のスレーブに対して最低2つの書き込み、2つの読み取り、または書き込みと読み取りの組み合わせを開始する結合メッセージ。

1つのデバイスが論理1を送信している、またはラインをフロートさせ、2番目のデバイスが論理0を送信している、またはラインをローに保持している場合、最初のデバイスはラインが論理1ではないことを検出できます。この検出をSCLxラインで使用する場合、クロックストレッチと呼ばれます。クロックストレッチは、スレーブデバイスにデータのフローを制御するメカニズムを提供します。この検出がSDAxラインで使用される場合、アービトレーションと呼ばれます。アービトレーションにより、一度に通信するマスターデバイスは1つだけになります。

### 24.3.1 CLOCK STRETCHING

スレーブデバイスがデータの処理を完了していない場合、クロックストレッチングのプロセスにより、さらに多くのデータの転送が遅延する可能性があります。
 アドレス指定されたスレーブデバイスは、ビットを受信または送信した後、SCLxクロックラインをLowに保持し、継続する準備がまだ整っていないことを示します。
 スレーブと通信しているマスターは、次のビットを転送するためにSCLxラインを上げようとしますが、クロックラインがまだ解放されていないことを検出します。
 SCLx接続はオープンドレインであるため、スレーブは通信を継続する準備ができるまでそのラインをローに保持することができます。
 クロックストレッチにより、トランスミッターに追いつけないレシーバーが着信データのフローを制御できます。

### 24.3.2 ARBITRATION

各マスターデバイスは、スタートビットとストップビットについてバスを監視する必要があります。
 デバイスは、バスがビジーであることを検出すると、バスがアイドル状態に戻るまで新しいメッセージを開始できません。
 ただし、2つのマスターデバイスがほぼ同時に送信を開始しようとする場合があります。
 これが発生すると、仲裁のプロセスが始まります。
 各トランスミッタは、SDAxデータラインのレベルをチェックし、それを検出すると予想されるレベルと比較します。
 2つのレベルが一致せず、アービトレーションを失い、SDAxラインでの送信を停止する必要があることを最初に確認するトランスミッター。
 たとえば、1つのトランスミッターがSDAxラインを論理1に保持（フロートさせる）し、2番目のトランスミッターが論理0に保持（ローにプル）する場合、結果はSDAxラインがローになります。
 最初の送信機は、回線のレベルが予想とは異なることを観察し、別の送信機が通信していると結論付けます。
 この違いに気づく最初のトランスミッタは、アービトレーションを失い、SDAxラインの駆動を停止する必要があるトランスミッタです。
 このトランスミッターがマスターデバイスでもある場合、SCLxラインの駆動も停止する必要があります。
 その後、送信を再発行する前に、停止状態がないかラインを監視できます。
 その間、SDAxラインの期待レベルと実際のレベルの違いに気づかなかった他のデバイスは、元の伝送を続行します。
 これまでのところ、他の送信機がメッセージを妨害することなく、送信が期待どおりに表示されるため、問題は発生しません。
 マスターが複数のスレーブをアドレス指定する場合、スレーブ送信モードも調停できますが、これはあまり一般的ではありません。
 2つのマスターデバイスがアドレスステージで2つの異なるスレーブデバイスにメッセージを送信している場合、下位のスレーブアドレスを送信しているマスターが常にアービトレーションに勝ちます。
 2つのマスターデバイスが同じスレーブアドレスにメッセージを送信し、アドレスが複数のスレーブを参照することがある場合、調停プロセスはデータステージに進む必要があります。
 仲裁は通常非常にまれですが、適切なマルチマスターサポートに必要なプロセスです。
 
## 24.4 I2Cモードの動作

すべてのMSSPx I2C通信はバイト指向で、MSbが最初にシフトアウトされます。
 6つのSFRレジスタと2つの割り込みフラグが、モジュールとPIC®マイクロコントローラーおよびユーザーソフトウェアとのインターフェースをとります。
 2つのピン、SDAxとSCLxは、モジュールによって実行され、他の外部I2Cデバイスと通信します。

### 24.4.1バイト形式

I2Cのすべての通信は9ビットセグメントで行われます。
 マスターからスレーブに、またはその逆にバイトが送信され、その後に確認応答ビットが送信されます。
 SCLxラインの8番目の立ち下がりエッジの後、SDAxでデータを出力するデバイスはそのピンを入力に変更し、次のクロックパルスで確認応答値を読み込みます。
 クロック信号SCLxはマスターから提供されます。
 データは、SCLx信号がLowの間に変更可能であり、クロックの立ち上がりエッジでサンプリングされます。
 SCLxラインがHighのときのSDAxラインの変化は、以下で説明するバス上の特別な条件を定義します。

### 24.4.2 I2C用語の定義

I2C通信の説明には、I2Cに固有の定義を持つ言語と用語があります。
 その単語の使用法は以下に定義されており、このドキュメントの残りの部分では説明なしに使用される場合があります。
 この表は、フィリップスI2C仕様に基づいています。

### 24.4.3 SDAXおよびSCLXピン

SSPxENビットがセットされたI2Cモードを選択すると、SCLxピンとSDAxピンが強制的にオープンドレインになります。
 これらのピンは、適切なTRISビットを設定することにより、ユーザーが入力に設定する必要があります。

注：I2Cモードが有効な場合、データは出力ゼロに関連付けられます。

### 24.4.4 SDAXホールドタイム

SDAxピンのホールドタイムは、SSPxCON3レジスタのSDAHTビットで選択します。
 ホールドタイムは、SCLxの立ち下がりエッジの後にSDAxが有効に保持される時間です。
 SDAHTビットを設定すると、300 ns以上の最小ホールドタイムが選択され、容量の大きなバスで役立つ場合があります。


TABLE 24-2: I2C BUS TERMS

用語 説明

送信機
データをバスにシフトアウトするデバイス。

受信機
バスからデータをシフトインするデバイス。

主人
転送を開始し、クロック信号を生成し、転送を終了するデバイス。

奴隷
マスターによってアドレス指定されたデバイス。

マルチマスター
データ転送を開始できる複数のデバイスを備えたバス。

仲裁
一度に1つのマスターのみがバスを制御するようにする手順。
調停に勝つと、メッセージが破損しないことが保証されます。

同期
バス上の2つ以上のデバイスのクロックを同期する手順。

アイドル
マスターがバスを制御しておらず、SDAxラインとSCLxラインの両方がHighです。

アクティブ
1つ以上のマスターデバイスがバスを制御しているとき。

アドレス指定されたスレーブ
一致するアドレスを受信し、マスターによってアクティブにクロックされているスレーブデバイス。

一致する住所
SSPxADDに保存されている値と一致するスレーブにクロックされるアドレスバイト。

書き込みリクエスト
スレーブはR / Wビットがクリアされた一致するアドレスを受信し、データを入力する準備ができています。

読み取りリクエスト
マスターは、R​​ / Wビットが設定されたアドレスバイトを送信し、
スレーブからデータをクロック出力したい。
 このデータは、再起動または停止まで、次のバイトとそれに続くすべてのバイトです。

クロックストレッチ
バス上のデバイスがSCLxをLowに保持して通信を停止した場合。

バス衝突
モジュールがSDAxラインを出力しているときに、モジュールがLowをサンプリングしてHigh状態になると予想されるとき。


### 24.4.5 START CONDITION

I2C仕様は、SCLxラインがハイの間にSDAxがハイからローの状態に遷移することとして開始条件を定義します。
 スタート条件は常にマスターによって生成され、アイドルからアクティブ状態へのバスの遷移を示します。
 図24-10は、開始条件と停止条件の波形を示しています。
 モジュールがSDAxラインをLowにアサートする前にLowをサンプリングすると、Start条件でバス衝突が発生する可能性があります。
 これはI2C仕様に準拠していません。これは、スタートでバス衝突が発生する可能性がないことを示しています。

### 24.4.6ストップ条件

 ストップ条件は、SCLxラインがハイの間にSDAxラインがローからハイに遷移することです。

注：ストップが有効になる前に、少なくとも1つのSCLxロー時間が表示される必要があるため、SCLxラインがハイのままでSDAxラインが再びローになり、ハイになった場合、開始条件のみが検出されます。

### 24.4.7再起動条件

再始動は、停止が有効な場合はいつでも有効です。
現在の転送の終了後にバスを保持したい場合、マスターは再起動を発行できます。
 再起動は、スレーブがStartと同じ効果を持ち、すべてのスレーブロジックをリセットして、アドレスでクロックする準備をします。
 マスターは、同じスレーブまたは別のスレーブをアドレス指定したい場合があります。
 10ビットアドレス指定スレーブモードでは、マスターがアドレス指定されたスレーブからデータをクロック出力するには、再起動が必要です。
 スレーブが完全にアドレス指定され、上位アドレスバイトと下位アドレスバイトの両方が一致すると、マスターは再起動とR / Wビットが設定された上位アドレスバイトを発行できます。
 その後、スレーブロジックはクロックを保持し、データをクロックアウトする準備をします。
 10ビットモードでR / Wがクリアされた完全一致の後、事前一致フラグが設定され、維持されます。
 ストップ条件が発生するまで、R / Wがクリアされた上位アドレス、または上位アドレスの一致は失敗します。

### 24.4.8開始/停止条件割り込みマスク

SSPxCON3レジスタのSCIEおよびPCIEビットを使用すると、通常この機能をサポートしないスレーブモードで割り込みを生成できます。
 開始および停止検出時の割り込みがすでに有効になっているスレーブモードでは、これらのビットは効果がありません。



### 24.4.9 確認シーケンス

I2Cで転送されたバイトの9番目のSCLxパルスは、確認応答専用です。
 これにより、SDAxラインをローにプルすることにより、受信デバイスがトランスミッタに応答することができます。
 トランスミッタは、応答をシフトするために、この時間中にラインの制御を解放する必要があります。
 肯定応答（ACK）はアクティブLOW信号であり、SDAxラインをLowにして、デバイスが送信データを受信し、さらにデータを受信する準備ができていることをトランスミッタに示します。
 ACKの結果は、SSPxCON2レジスタのACKSTATビットに格納されます。
 スレーブソフトウェアでは、AHENおよびDHENビットが設定されている場合、ユーザーはトランスミッタに送り返されるACK値を設定できます。
 SSPxCON2レジスタのACKDTビットは、応答を決定するためにセット/クリアされます。
 SSPxCON3レジスタのAHENおよびDHENビットがクリアされている場合、スレーブハードウェアはACK応答を生成します。スレーブがACKを送信しない特定の条件があります。
 バイトの受信時に、SSPxSTATレジスタのBFビットまたはSSPxCON1レジスタのSSPxOVビットがセットされている場合。
 モジュールがアドレス指定されると、バス上のSCLxの8番目の立ち下がりエッジの後に、SSPxCON3レジスタのACKTIMビットがセットされます。
 ACKTIMビットは、アクティブバスの確認応答時間を示します。
 ACKTIMステータスビットは、AHENビットまたはDHENビットが有効な場合にのみアクティブになります。


## 24.5 I2Cスレーブモードの動作

MSSPxスレーブモードは、SSPxCON1レジスタのSSPxMビットで選択された4つのモードのいずれかで動作します。
 モードは、7ビットと10ビットのアドレッシングモードに分割できます。
。 10ビットアドレッシングモードは7ビットと同じように動作し、より大きなアドレスを処理するためのオーバーヘッドが追加されます。
 StartおよびStopビット割り込みを使用するモードは、SSPxIFを使用して他のモードと同様に動作し、Start、Restart、またはStop条件の検出時にさらに設定されます。

### 24.5.1スレーブモードアドレス

SSPxADDレジスタ（レジスタ24-6）には、スレーブモードアドレスが含まれています。
 開始条件または再起動条件の後に受信した最初のバイトは、このレジスタに格納されている値と比較されます。
 バイトが一致すると、値がSSPxBUFレジスタにロードされ、割り込みが生成されます。
 値が一致しない場合、モジュールはアイドル状態になり、ソフトウェアに何かが起こったことを示すものはありません。
 SSPxマスクレジスタ（レジスタ24-5）は、アドレス照合プロセスに影響を与えます。
 詳細はセクション24.5.9「SSPxマスクレジスタ」を参照してください。

#### 24.5.1.1 I2Cスレーブ7ビットアドレッシングモード

7ビットアドレッシングモードでは、アドレスが一致するかどうかを判断するときに、受信したデータバイトのLSbは無視されます。

#### 24.5.1.2 I2Cスレーブ10ビットアドレッシングモード

10ビットアドレッシングモードでは、最初に受信したバイトが「1 1 1 1 0 A9 A8 0」のバイナリ値と比較されます。
 A9とA8は10ビットアドレスの2つのMSbで、SSPxADDレジスタのビット2と1に格納されます。
 上位バイトの確認応答後、UAビットが設定され、ユーザーが下位アドレスでSSPxADDを更新するまでSCLxがLowに保持されます。
。下位アドレスバイトが入力され、8ビットすべてがSSPxADDの下位アドレス値と比較されます。
 一致する住所がない場合でも、 SSPxIFとUAが設定され、SCLxはSSPxADDが更新されて再び上位バイトを受信するまでLowに保持されます。
 SSPxADDが更新されると、UAビットがクリアされます。
 これにより、モジュールは次の通信で上位アドレスバイトを受信する準備ができています。
 すべての10ビットアドレッシング通信の開始時に、書き込み要求としての上位アドレスと下位アドレスの一致が必要です。
 スレーブがアドレス指定されたら再起動を発行し、R / Wビットをセットして上位アドレスにクロック入力することにより、送信を開始できます。
 次に、スレーブハードウェアが読み取り要求を確認し、データをクロックアウトする準備をします。
 これは、スレーブが完全な上位アドレスバイトと下位アドレスバイトの一致を受信した後にのみ有効です。

### 24.5.2スレーブ受信

一致する受信アドレスバイトのR / Wビットがクリアされると、SSPxSTATレジスタのR / Wビットがクリアされます。
 受信したアドレスはSSPxBUFレジスタにロードされ、確認されます。
  受信アドレスにオーバーフロー条件が存在する場合、確認応答は行われません。
   オーバーフロー状態は、SSPxSTATレジスタのBFビットが設定されているか、SSPxCON1レジスタのSSPxOVビットが設定されていると定義されます。
    SSPxCON3レジスタのBOENビットは、この動作を変更します。
   詳細については、レジスタ24-4を参照してください。
    MSSPx割り込みは、転送されたデータバイトごとに生成されます。
     フラグビットSSPxIFは、ソフトウェアでクリアする必要があります。
      SSPxCON2レジスタのSENビットがセットされている場合、SCLxは各受信バイトに続いてLow（クロックストレッチ）に保持されます。
       クロックは、10ビットモードの場合を除いて、SSPxCON1レジスタのCKPビットを設定して解放する必要があります。
      詳細はセクション24.2.3「SPIマスターモード」を参照してください。

#### 24.5.2.1 7ビットアドレッシング受信

このセクションでは、7ビットアドレッシングモードでI2Cスレーブとして構成されたMSSPxモジュールの標準的なイベントシーケンスについて説明します。
 ハードウェアまたはソフトウェアによって行われたすべての決定と、受信への影響。
 図24-13および図24-14は、この説明の視覚的な参照として使用されます。
  これは、I2C通信を実現するために通常実行する必要があるステップバイステップのプロセスです。
  
1.開始ビットが検出されました。
2.SSPxSTATのSビットが設定されている。開始検出時の割り込みが有効な場合、SSPxIFが設定されます。
3.R / Wビットがクリアされた一致アドレスが受信されます。
4.スレーブはSDAxをローにプルしてACKをマスターに送信し、SSPxIFビットをセットします。
5.ソフトウェアはSSPxIFビットをクリアします。
6.ソフトウェアは受信したアドレスをSSPxBUFから読み取り、BFフラグをクリアします。
7.SEN = 1の場合。スレーブソフトウェアは、CKPビットをセットしてSCLxラインを解放します。
8.マスターはデータバイトをクロックアウトします。
9.スレーブがSDAxをLowに駆動してマスターにACKを送信し、SSPxIFビットをセットします。
10.ソフトウェアがSSPxIFをクリアします。
11.ソフトウェアは、BFをクリアするSSPxBUFから受信バイトを読み取ります。
12.マスターから受信したすべてのバイトについて、手順8〜12が繰り返されます。
13.マスターがストップ条件を送信し、SSPxSTATのPビットをセットし、バスがアイドル状態になります。

#### 24.5.2.2 7-bit Reception with AHEN and DHEN

AHENおよびDHENが設定されたスレーブデバイスの受信は、これらのオプションがない場合と同じように動作し、SCLxの8番目の立ち下がりエッジの後に追加の割り込みとクロックストレッチが追加されます。
 これらの追加の割り込みにより、スレーブソフトウェアは、ハードウェアではなく、受信アドレスまたはデータバイトにACKを送信するかどうかを決定できます。
  この機能により、このモジュールの以前のバージョンにはなかったPMBus™のサポートが追加されます。
  このリストでは、I2C通信でこれらのオプションを使用するためにスレーブソフトウェアで実行する必要がある手順について説明します。
 図24-15に、アドレスとデータ保持の両方を使用するモジュールを示します。
  図24-16に、SSPxCON2レジスタセットのSENビットを使用した動作を示します。

1.SSPxSTATのSビットが設定されている。開始検出時の割り込みが有効な場合、SSPxIFが設定されます。
2.R / Wビットがクリアされた一致するアドレスが入力されます。
3.SCLxの8番目の立ち下がりエッジの後にSSPxIFがセットされ、CKPがクリアされます。
4.スレーブがSSPxIFをクリアします。
5.スレーブはSSPxCON3レジスタのACKTIMビットを見て、SSPxIFがACKの後か前かを判断できます。
6.スレーブはSSPxBUFからアドレス値を読み取り、BFフラグをクリアします。
7.スレーブは、ACKDTを設定して、マスターにクロックアウトされるACK値を設定します。
8.スレーブはCKPを設定してクロックを解放します。
9.SSPxIFは、NACKの後にではなく、ACKの後に設定されます。
10.SEN = 1の場合、スレーブハードウェアはACKの後にクロックをストレッチします。

注：SSPxIFは、クロックストレッチがなく、BFがクリアされていても、SCLxの9番目の立ち下がりエッジの後に設定されます。 NACKがマスターに送信される場合のみ、SSPxIFは設定されません。

11.スレーブがSSPxIFをクリアします。
12.受信したデータバイトのSCLxの8番目の立ち下がりエッジの後にSSPxIFがセットされ、CKPがクリアされます。
13.スレーブはSSPxCON3のACKTIMビットを見て、割り込みのソースを判別します。
14.スレーブはSSPxBUFから受信データを読み取り、BFをクリアします。
15.手順7-14は、受信した各データバイトで同じです。
16.通信はスレーブによって終了されます
ACK = 1を送信するか、マスターがストップ条件を送信します。
 ストップが送信され、ストップ検出時の割り込みが無効になっている場合、スレーブはSSTSTATレジスタのPビットをポーリングすることによってのみ認識します。


### 24.5.3 スレーブ送信

入力アドレスバイトのR / Wビットがセットされ、アドレス一致が発生すると、SSPxSTATレジスタのR / Wビットがセットされます。
 受信したアドレスはSSPxBUFレジスタにロードされ、スレーブによって9番目のビットでACKパルスが送信されます。
 ACKに続いて、スレーブハードウェアがCKPビットをクリアし、SCLxピンがLowに保持されます（詳細は、セクション24.5.6「クロックストレッチ」を参照）。
 クロックをストレッチすることにより、スレーブが送信データの準備を完了するまで、マスターは別のクロックパルスをアサートできなくなります。
 送信データは、SSPxSRレジスタもロードするSSPxBUFレジスタにロードする必要があります。
 次に、SSPxCON1レジスタのCKPビットをセットして、SCLxピンを解放する必要があります。
 8つのデータビットは、SCLx入力の立ち下がりエッジでシフトアウトされます。
 これにより、SCLxがHighの間、SDAx信号が有効になります。
 マスターレシーバーからのACKパルスは、9番目のSCLx入力パルスの立ち上がりエッジでラッチされます。
 このACK値は、SSPxCON2レジスタのACKSTATビットにコピーされます。
 ACKSTATが設定されている（ACKではない）場合、データ転送は完了しています。
 この場合、not ACKがスレーブによってラッチされると、スレーブはアイドル状態になり、もう一度Startビットが発生するのを待ちます。
 SDAxラインがロー（ACK）の場合、次の送信データをSSPxBUFレジスタにロードする必要があります。
 この場合も、ビットCKPをセットしてSCLxピンを解放する必要があります。
 MSSPx割り込みは、データ転送バイトごとに生成されます。
 SSPxIFビットはソフトウェアでクリアする必要があり、SSPxSTATレジスタを使用してバイトのステータスを判別します。
 SSPxIFビットは、9番目のクロックパルスの立ち下がりエッジでセットされます。

#### 24.5.3.1スレーブモードバスの衝突

スレーブは読み取り要求を受信し、SDAxラインでデータのシフトアウトを開始します。
 バス衝突が検出され、SSPxCON3レジスタのSBCDEビットがセットされている場合、PIRxレジスタのBCLxIFビットがセットされます。
 バスの衝突が検出されると、スレーブはアイドルになり、再びアドレス指定されるのを待ちます。
 ユーザーソフトウェアは、BCLxIFビットを使用してスレーブバスの衝突を処理できます。




#### 24.5.3.2 7ビット送信

マスターデバイスは、読み取り要求をスレーブに送信し、スレーブからデータをクロック出力できます。以下のリストは、標準的な送信を実行するためにスレーブのソフトウェアが実行する必要のあることを概説しています。
図24-17は、このリストへの参照として使用できます。
1.マスターがSDAxおよびSCLxで開始条件を送信します。
2.
 SSPxSTATのSビットが設定されている。開始検出時の割り込みが有効な場合、SSPxIFが設定されます。
3.
 R / Wビットが設定された一致アドレスは、スレーブ設定SSPxIFビットによって受信されます。
4.スレーブハードウェアがACKを生成し、SSPxIFを設定します。
5.
 SSPxIFビットはユーザーによってクリアされます。
6.ソフトウェアはSSPxBUFから受信アドレスを読み取り、BFをクリアします。
7.
 R / Wが設定されているため、ACK後にCKPが自動的にクリアされました。
8.スレーブソフトウェアが送信データをSSPxBUFにロードします。
9.
 CKPビットがセットされてSCLxを解放し、マスターがスレーブからデータをクロック出力できるようにします。
10.
 SSPxIFは、マスターからのACK応答がACKSTATレジスタにロードされた後に設定されます。
11.
 SSPxIFビットがクリアされます。
12.スレーブソフトウェアはACKSTATビットをチェックして、マスターがさらに多くのデータを出力したいかどうかを確認します。

注1：マスターがACKを受信すると、クロックが引き延ばされます。
2：ACKSTATは、SCLx（9番目）の立ち下がりではなく、立ち上がりエッジで更新される唯一のビットです。

13.手順9〜13は、送信されたバイトごとに繰り返されます。
14.マスターがnot ACKを送信した場合。クロックは保持されませんが、SSPxIFは設定されたままです。
15.マスターが再起動条件または停止を送信します。
16.スレーブはもはやアドレス指定されていません。


## 24.6 I2C MASTER MODE

マスターモードを有効にするには、SSPxCON1レジスタの適切なSSPxMビットをセットおよびクリアし、SSPxENビットをセットします。
 マスターモードでは、SCLxおよびSDAxラインは入力として設定され、MSSPxハードウェアによって操作されます。
 マスター動作モードは、開始条件と停止条件の検出時の割り込み生成によってサポートされます。
 ストップ（P）およびスタート（S）ビットは、リセットから、またはMSSPxモジュールが無効になるとクリアされます。
 I2Cバスの制御は、Pビットが設定されているとき、またはバスがアイドル状態のときに行われます。
 ファームウェア制御マスターモードでは、ユーザーコードはすべてのI2Cバス操作を開始および停止ビット条件検出に基づいて実行します。
 このモードでアクティブな回路は、開始条件と停止条件の検出のみです。
 他のすべての通信は、SDAxおよびSCLxラインを直接操作するユーザーソフトウェアによって行われます。
 以下のイベントにより、SSPx割り込みフラグビットSSPxIFが設定されます（有効になっている場合はSSPx割り込み）。
•検出された開始条件
•停止条件が検出されました
•送受信されるデータ転送バイト
•送信/受信の確認
•繰り返し開始が生成されました

注1：MSSPxモジュールは、I2Cマスターモードで構成されている場合、イベントのキューイングを許可しません。
たとえば、ユーザーは開始条件を開始して、開始条件が完了する前に送信を開始するためにSSPxBUFレジスタにすぐに書き込むことはできません。
この場合、SSPxBUFへの書き込みは行われず、WCOLビットが設定され、SSPxBUFへの書き込みが発生しなかったことを示します。
2：マスターモードでは、SEN / PENビットがクリアされて生成が完了すると、開始/停止検出がマスクされ、割り込みが生成されます。


24.6.1 I2Cマスターモードの動作

マスターデバイスは、すべてのシリアルクロックパルスと開始および停止条件を生成します。
 転送は、ストップ条件またはリピートスタート条件で終了します。
 リピートスタート条件は次のシリアル転送の開始でもあるため、I2Cバスは解放されません。
 マスタトランスミッタモードでは、シリアルデータはSDAxを介して出力され、SCLxはシリアルクロックを出力します。
 送信される最初のバイトには、受信デバイスのスレーブアドレス（7ビット）と読み取り/書き込み（R / W）ビットが含まれます。
 この場合、R / Wビットは論理「0」になります。
 シリアルデータは一度に8ビット送信されます。
 各バイトが送信された後、Acknowledgeビットが受信されます。
 シリアル転送の開始と終了を示す開始条件と停止条件が出力されます。
 マスター受信モードでは、送信される最初のバイトには、送信デバイスのスレーブアドレス（7ビット）とR / Wビットが含まれます。
 この場合、R / Wビットは論理「1」になります。
 したがって、送信される最初のバイトは7ビットのスレーブアドレスで、その後に受信ビットを示す「1」が続きます。
 シリアルデータはSDAx経由で受信され、SCLxはシリアルクロックを出力します。
 シリアルデータは一度に8ビット受信されます
。各バイトが受信されると、Acknowledgeビットが送信されます。
 開始条件と停止条件は、送信の開始と終了を示します。
 ボーレートジェネレータを使用して、SCLxのクロック周波数出力を設定します。
 詳細は、セクション24.7「ボーレートジェネレータ」を参照してください。

### 24.6.2 CLOCK ARBITRATION

クロックアービトレーションは、マスターが、受信、送信、または反復開始/停止条件の間にSCLxピンを解放するときに発生します（SCLxをハイにフロートさせることができます）。
 SCLxピンがHighにフロートできると、ボーレートジェネレータ（BRG）は、SCLxピンが実際にHighにサンプリングされるまでカウントを停止します。
 SCLxピンがHighでサンプリングされると、baudレートジェネレータにSSPxADD <7：0>の内容がリロードされ、カウントを開始します。
 これにより、外部デバイスによってクロックがLowに保持されている場合、SCLxのHigh時間は常に少なくとも1つのBRGロールオーバーカウントになります（図24-25）。

### 24.6.3 WCOL STATUS FLAG

開始、再起動、停止、受信、または送信シーケンスの進行中にユーザーがSSPxBUFを書き込むと、WCOLが設定され、バッファーの内容は変更されません（書き込みは行われません）。
 WCOLビットが設定されている場合は常に、モジュールがアイドル状態ではないときにSSPxBUFでアクションが試行されたことを示します。

注：イベントのキューイングは許可されていないため、開始条件が完了するまで、SSPxCON2の下位5ビットへの書き込みは無効になります。

### 24.6.4 I2Cマスターモードの開始条件のタイミング

スタート条件を開始するには、ユーザーはSSPxCON2レジスタのスタートイネーブルビット、SENビットをセットします。
 SDAxピンとSCLxピンがHighでサンプリングされると、baudレートジェネレータにSSPxADD <7：0>の内容がリロードされ、カウントが開始されます。
 baudレートジェネレータがタイムアウト（TBRG）するときにSCLxとSDAxの両方がハイでサンプリングされる場合、SDAxピンはローに駆動されます。
 SCLxがHighのときにSDAxがLowに駆動される動作は開始条件であり、SSPxSTAT1レジスタのSビットがセットされます。
 これに続いて、baudレートジェネレータにSSPxADD <7：0>の内容がリロードされ、カウントが再開されます。
 ボーレートジェネレータがタイムアウトすると（TBRG）、SSPxCON2レジスタのSENビットがハードウェアによって自動的にクリアされます。 baudレートジェネレータが一時停止され、SDAxラインがLowに保持され、開始条件が完了します。

注1：スタート条件の初めに、SDAxピンとSCLxピンが既にLowにサンプリングされている場合、またはスタート条件中にSDAxラインがLowに駆動される前にSCLxラインがLowにサンプリングされると、バス衝突が発生し、バス衝突割り込みフラグBCLxIFが設定され、開始条件が中止され、I2Cモジュールがアイドル状態にリセットされます。
2：Philips I2C仕様では、スタート時にバス衝突は発生しないと規定されています。

### 24.6.5 I2Cマスターモードリピート開始条件タイミング

SSPxCON2レジスタのRSENビットがハイにプログラムされていて、マスタステートマシンがアクティブではなくなったときに、リピートスタート条件が発生します。
 RSENビットがセットされると、SCLxピンがLowにアサートされます。
 SCLxピンがLowでサンプリングされると、baudレートジェネレータがロードされ、カウントを開始します。
 SDAxピンは、1つのボーレートジェネレータカウント（TBRG）で解放されます（ハイになります）。
 ボーレートジェネレータがタイムアウトすると、SDAxがHighでサンプリングされると、SCLxピンがディアサートされます（Highになります）。
 SCLxがハイでサンプリングされると、ボーレートジェネレータがリロードされ、カウントを開始します。
 SDAxとSCLxは、1つのTBRGでハイにサンプリングする必要があります。
 次に、このアクションの後に、SCLxがハイの間に1つのTBRGのSDAxピン（SDAx = 0）がアサートされます。
 SCLxがLowにアサートされます。
 この後、SSPxCON2レジスタのRSENビットは自動的にクリアされ、ボーレートジェネレータはリロードされず、SDAxピンはLowのままになります。
 SDAxピンとSCLxピンで開始条件が検出されるとすぐに、SSPxSTATレジスタのSビットがセットされます。
 SSPxIFビットは、ボーレートジェネレータがタイムアウトするまでセットされません。

注1：他のイベントの進行中にRSENがプログラムされた場合、RSENは有効になりません。
2：以下の場合、リピートスタート条件の間のバス衝突が発生します。
•SCLxがローからハイになると、SDAxはローにサンプリングされます。
•SDAxがLowにアサートされる前にSCLxがLowになります。これは、別のマスターがデータ「1」を送信しようとしていることを示している可能性があります。

### 24.6.6 I2C MASTER MODE TRANSMISSION

データバイト、7ビットアドレス、または10ビットアドレスの残りの半分の送信は、SSPxBUFレジスタに値を書き込むだけで実行できます。
 このアクションにより、バッファフルフラグビットBFが設定され、ボーレートジェネレータがカウントを開始して次の送信を開始できるようになります。
 SCLxの立ち下がりエッジがアサートされた後、アドレス/データの各ビットがSDAxピンにシフトアウトされます。
 SCLxは、1つのボーレートジェネレータロールオーバーカウント（TBRG）の間、ローに保持されます。
 SCLxがHighにリリースされる前に、データは有効である必要があります。
 SCLxピンがHighに解放されると、TBRGに対してそのように保持されます。
 SDAxピンのデータは、その期間、およびSCLxの次の立ち下がりエッジ後のホールド時間の間、安定した状態を保つ必要があります。
 8番目のビットがシフトアウトされた後（8番目のクロックの立ち下がりエッジ）、BFフラグがクリアされ、マスターがSDAxを解放します。
 これにより、アドレスが一致した場合、またはデータが正しく受信された場合、アドレス指定されているスレーブデバイスは、9番目のビット時間中にACKビットで応答できます。
 ACKのステータスは、9番目のクロックの立ち上がりエッジでACKSTATビットに書き込まれます。
 マスターが確認応答を受信すると、確認ステータスビットACKSTATがクリアされます。
 そうでない場合、ビットが設定されます。
 9番目のクロックの後、SSPxIFビットがセットされ、マスタークロック（ボーレートジェネレーター）は、次のデータバイトがSSPxBUFにロードされるまで一時停止され、SCLxはロー、SDAxは変更されません（図24-27）。
 SSPxBUFへの書き込み後、アドレスの各ビットは、7つのアドレスビットすべてとR / Wビットが完了するまで、SCLxの立ち下がりエッジでシフトアウトされます。
 8番目のクロックの立ち下がりエッジで、マスターはSDAxピンを解放し、スレーブが確認応答で応答できるようにします。
 9番目のクロックの立ち下がりエッジで、マスターはSDAxピンをサンプリングして、アドレスがスレーブによって認識されたかどうかを確認します。
 ACKビットのステータスは、SSPxCON2レジスタのACKSTATステータスビットにロードされます。
 アドレスの9番目のクロック送信の立ち下がりエッジに続いて、SSPxIFがセットされ、BFフラグがクリアされ、SSPxBUFへの別の書き込みが行われるまでbaudレートジェネレータがオフになり、SCLxをLowに保持してSDAxをフロートさせます。